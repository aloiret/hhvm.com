---
author: bsimmers
layout: post
title: 'Faster and Cheaper: The Evolution of the hhvm JIT'
category: blog
permalink: /blog/2027/faster-and-cheaper-the-evolution-of-the-hhvm-jit
comments:
- id: 2075
  author: dawehner
  author_email: dawehner@googlemail.com
  author_url: ''
  date: '2013-12-12 12:20:24 +0000'
  date_gmt: '2013-12-12 20:20:24 +0000'
  content: We have december now, so it would be great to have the graph extended until
    now.
- id: 2081
  author: Is Facebook Planning a Move to ARM Based Servers? | Joseph Scott
  author_email: ''
  author_url: https://josephscott.org/archives/2013/12/is-facebook-planning-a-move-to-arm-based-servers/
  date: '2013-12-13 08:36:27 +0000'
  date_gmt: '2013-12-13 16:36:27 +0000'
  content: "[&#8230;] latest update from Facebook about the HHVM JIT ended with this
    interesting note, emphasis [&#8230;]"
- id: 2087
  author: Brett Simmers
  author_email: bsimmers@fb.com
  author_url: http://fb.me/bsimmers
  date: '2013-12-13 12:44:35 +0000'
  date_gmt: '2013-12-13 20:44:35 +0000'
  content: One of our other devs is working on a post about more recent perf improvements,
    so that should have newer graphs.
- id: 2093
  author: Facebook hints at ARM server deployment too &mdash; Tech News and Analysis
  author_email: ''
  author_url: http://gigaom.com/2013/12/13/facebook-hints-at-arm-server-deployment-too/
  date: '2013-12-13 13:34:52 +0000'
  date_gmt: '2013-12-13 21:34:52 +0000'
  content: "[&#8230;] it was rumors of Google building ARM-based servers, and now
    a post on the blog dedicated to Facebook&#8217;s HipHop Virtual Machine for PHP
    code notes how its translation engine plays a &#8220;crucial in our efforts to
    get hhvm running on ARM [&#8230;]"
- id: 2099
  author: Facebook hints at ARM server deployment too | My Website
  author_email: ''
  author_url: http://atechsite.com/?p=26407
  date: '2013-12-13 13:41:18 +0000'
  date_gmt: '2013-12-13 21:41:18 +0000'
  content: "[&#8230;] it was rumors of Google building ARM-based servers, and now
    a post on the blog dedicated to Facebook&rsquo;s HipHop Virtual Machine for PHP
    code notes how its translation engine plays a &ldquo;crucial in our efforts to
    get hhvm running on ARM [&#8230;]"
- id: 2105
  author: Facebook hints at ARM server deployment too | 8ballbilliard
  author_email: ''
  author_url: http://www.8ballbilliard.com/facebook-hints-at-arm-server-deployment-too/
  date: '2013-12-13 14:13:43 +0000'
  date_gmt: '2013-12-13 22:13:43 +0000'
  content: "[&#8230;] it was rumors of Google build&shy;ing ARM-based servers, and
    now a post on the blog ded&shy;i&shy;cated to Facebook&rsquo;s HipHop Vir&shy;tual
    Machine for PHP code notes how its trans&shy;la&shy;tion engine plays a &ldquo;cru&shy;cial
    in our efforts to get hhvm run&shy;ning on [&#8230;]"
- id: 2111
  author: Facebook hints at ARM server deployment too | IT News
  author_email: ''
  author_url: http://www.itaggregator.tk/?p=19
  date: '2013-12-13 14:46:39 +0000'
  date_gmt: '2013-12-13 22:46:39 +0000'
  content: "[&#8230;] it was rumors of Google building ARM-based servers, and now
    a post on the blog dedicated to Facebook&#8217;s HipHop Virtual Machine for PHP
    code notes how its translation engine plays a &#8220;crucial in our efforts to
    get hhvm running on ARM [&#8230;]"
- id: 2117
  author: Facebook hints at ARM server deployment too | Content Loop
  author_email: ''
  author_url: http://news.jurjenbloo.nl/2013/12/facebook-hints-at-arm-server-deployment-too/
  date: '2013-12-13 14:55:19 +0000'
  date_gmt: '2013-12-13 22:55:19 +0000'
  content: "[&#8230;] it was rumors of Google building ARM-based servers, and now
    a post on the blog dedicated to Facebook&rsquo;s HipHop Virtual Machine for PHP
    code notes how its translation engine plays a &ldquo;crucial in our efforts to
    get hhvm running on ARM [&#8230;]"
- id: 2123
  author: Facebook hints at ARM server deployment too | Earthgrid
  author_email: ''
  author_url: http://blog.earthgrid.com/cloud/facebook-hints-at-arm-server-deployment-too/
  date: '2013-12-15 00:14:46 +0000'
  date_gmt: '2013-12-15 08:14:46 +0000'
  content: "[&#8230;] it was rumors of Google building ARM-based servers, and now
    a post on the blog dedicated to Facebook&#8217;s HipHop Virtual Machine for PHP
    code notes how its translation engine plays a &#8220;crucial in our efforts to
    get hhvm running on ARM [&#8230;]"
- id: 2129
  author: Facebook porting its PHP engine to ARM | High Performance Computing Info
  author_email: ''
  author_url: http://hpc2go.wordpress.com/2013/12/15/facebook-porting-its-php-engine-to-arm/
  date: '2013-12-15 00:52:43 +0000'
  date_gmt: '2013-12-15 08:52:43 +0000'
  content: "[&#8230;] the HHVM blog post and an article at The [&#8230;]"
- id: 2135
  author: 'Programowanie w PHP &raquo; Blog Archive &raquo; HipHop Blog: Faster and
    Cheaper: The Evolution of the hhvm JIT'
  author_email: ''
  author_url: http://php-soft.cba.pl/?p=4274
  date: '2013-12-15 14:26:02 +0000'
  date_gmt: '2013-12-15 22:26:02 +0000'
  content: "[&#8230;] the HHVM (HipHop Virtal Machine) blog there&#8217;s a new post
    that looks at the evolution of the HHVM JIT compiler since the project started
    about four years [&#8230;]"
- id: 2141
  author: ''
  author_email: ''
  author_url: http://prog.hu/hirek/3395/Gyorsabban+fut+a+PHP+kod+a+Facebook+VM-jen+mint+a+C-plus-plus-ra+forditott+tarsa.html
  date: '2013-12-15 22:15:02 +0000'
  date_gmt: '2013-12-16 06:15:02 +0000'
  content: "[&#8230;]  [&#8230;]"
- id: 2147
  author: Facebook ใช้งาน HipHop VM เต็มตัว, ประสิทธิภาพดีกว่ารุ่น C++, เตรียมรันบน
    ARM | ข่าวล่าสุด
  author_email: ''
  author_url: http://xn--22c0bwchq9bc3c0id.com/2013/12/16/facebook-%e0%b9%83%e0%b8%8a%e0%b9%89%e0%b8%87%e0%b8%b2%e0%b8%99-hiphop-vm-%e0%b9%80%e0%b8%95%e0%b9%87%e0%b8%a1/
  date: '2013-12-16 07:10:14 +0000'
  date_gmt: '2013-12-16 15:10:14 +0000'
  content: "[&#8230;] &#8211; HHVM, The [&#8230;]"
- id: 2153
  author: Facebook PHP engine eyeing move to ARM server chips - Crutch Technologies
  author_email: ''
  author_url: http://www.crutchtech.com/2013/12/16/facebook-php-engine-eyeing-move-to-arm-server-chips/
  date: '2013-12-16 10:58:09 +0000'
  date_gmt: '2013-12-16 18:58:09 +0000'
  content: "[&#8230;] post on the Hip Hop Virtual Machine (HHVM) blog on Thursday
    indicated that the team there is implementing ARM processor support into its [&#8230;]"
- id: 2159
  author: Facebook PHP engine eyeing move to ARM server chips | TechWorthy.info
  author_email: ''
  author_url: http://techworthy.info/2013/12/16/facebook-php-engine-eyeing-move-to-arm-server-chips/
  date: '2013-12-16 12:31:55 +0000'
  date_gmt: '2013-12-16 20:31:55 +0000'
  content: "[&#8230;] post on the Hip Hop Virtual Machine (HHVM) blog on Thursday
    indicated that the team there is implementing ARM processor support into its [&#8230;]"
- id: 2165
  author: Facebook PHP engine eyeing move to ARM server chips | Plugged Into The Matrix
  author_email: ''
  author_url: http://pluggedintothematrix.com/facebook-php-engine-eyeing-move-to-arm-server-chips/
  date: '2013-12-16 12:32:43 +0000'
  date_gmt: '2013-12-16 20:32:43 +0000'
  content: "[&#8230;] post on the Hip Hop Virtual Machine (HHVM) blog on Thursday
    indicated that the team there is implementing ARM processor support into its [&#8230;]"
- id: 2171
  author: Nowe Technologie | Google stworzy własne mikroprocesory na rdzeniach ARM?
  author_email: ''
  author_url: http://aktualnosci.nowetech.pl/google-stworzy-wlasne-mikroprocesory-na-rdzeniach-arm/
  date: '2013-12-17 01:34:47 +0000'
  date_gmt: '2013-12-17 09:34:47 +0000'
  content: "[&#8230;] właśnie swoje plany dotyczące wykorzystania procesor&oacute;w
    z rdzeniami ARM ogłosił Facebook, informując, że bliski jest przeniesienia kompilator&oacute;w
    PHP na nową architekturę, a następnie publikując [&#8230;]"
- id: 2177
  author: Facebook PHP engine eyeing move to ARM server chips &#124; Techy News Today
  author_email: ''
  author_url: http://techynewstoday.com/facebook-php-engine-eyeing-move-to-arm-server-chips/
  date: '2013-12-17 08:02:36 +0000'
  date_gmt: '2013-12-17 16:02:36 +0000'
  content: "[&#8230;] post on the Hip Hop Virtual Machine (HHVM) blog on Thursday
    indicated that the team there is implementing ARM processor support into its [&#8230;]"
- id: 2183
  author: Facebook hints at ARM server deployment too | VIGALUM
  author_email: ''
  author_url: http://www.vigalum.com/facebook-hints-at-arm-server-deployment-too/
  date: '2013-12-19 16:20:04 +0000'
  date_gmt: '2013-12-20 00:20:04 +0000'
  content: "[&#8230;] it was rumors of Google building ARM-based servers, and now
    a post on the blog dedicated to Facebook&#8217;s HipHop Virtual Machine for PHP
    code notes how its translation engine plays a &#8220;crucial in our efforts to
    get hhvm running on ARM [&#8230;]"
- id: 2189
  author: Eltechs Facebook Considers Shift to ARM-based Servers
  author_email: ''
  author_url: http://eltechs.com/facebook-considers-shift-to-arm-based-servers/
  date: '2014-01-21 01:11:39 +0000'
  date_gmt: '2014-01-21 09:11:39 +0000'
  content: "[&#8230;] recent post on Hip Hop Virtual Machine (HHVM) blog indicates
    that the team works on implementing ARM support. HHVM is a Facebook&#8217;s PHP
    engine [&#8230;]"
- id: 2195
  author: HHVM and Hack - Part 1 - SitePoint
  author_email: ''
  author_url: http://www.sitepoint.com/hhvm-hack-part-1/
  date: '2014-02-12 09:02:40 +0000'
  date_gmt: '2014-02-12 17:02:40 +0000'
  content: "[&#8230;] HPHPc did a good job on improving performance but it was not
    without issues: maintaining both HPHPc and HPHPi in sync proved to be cumbersome
    plus some differences still existed between the transpiled code vs the interpreted
    one. That&#039;s why back in 2010 Facebook decided to go for another approach
    and created HHVM &#8211; a new virtual machine designed to replace the Zend Engine
    used by PHP. By the end of 2012 HHVM achieved performance parity with the former
    HPHPc and soon surpassed it. [&#8230;]"
- id: 2201
  author: HHVM and Hack &ndash; Part 1 &#8211; Bruno &Scaron;kvorc | WarWebDev
  author_email: ''
  author_url: http://warwebdev.com/2014/02/hhvm-and-hack-part-1-bruno-skvorc/
  date: '2014-02-12 10:14:25 +0000'
  date_gmt: '2014-02-12 18:14:25 +0000'
  content: "[&#8230;] HPHPc did a good job on improving performance but it was not
    without issues: maintaining both HPHPc and HPHPi in sync proved to be cumbersome
    plus some differences still existed between the transpiled code vs the interpreted
    one. That&#8217;s why back in 2010 Facebook decided to go for another approach
    and created HHVM &ndash; a new virtual machine designed to replace the Zend Engine
    used by PHP. By the end of 2012 HHVM achieved performance parity with the former
    HPHPc and soon surpassed it. [&#8230;]"
- id: 2207
  author: 'HHVM: The Next Six Months &laquo; HipHop Virtual Machine'
  author_email: ''
  author_url: http://www.hhvm.com/blog/3743/hhvm-the-next-six-months
  date: '2014-02-25 14:04:25 +0000'
  date_gmt: '2014-02-25 22:04:25 +0000'
  content: "[&#8230;] set very aggressive efficiency goals for the half that we hope
    to achieve through a range of&nbsp;JIT compiler&nbsp;projects. We hope these translate
    into wins for a variety of PHP workloads. We&rsquo;re shooting for [&#8230;]"
- id: 4853
  author: 'Advanced Micro Devices, Inc. (AMD) news: My Best 2014 Catalyst For AMD
    Is &#8230; &#8211; Seeking Alpha | Home audio market'
  author_email: ''
  author_url: http://homeaudiomarket.com/blog/electronics/advanced-micro-devices-inc-amd-news-my-best-2014-catalyst-for-amd-is-seeking-alpha/
  date: '2014-03-24 10:54:59 +0000'
  date_gmt: '2014-03-24 17:54:59 +0000'
  content: "[&#8230;] promise of very energy-efficient ARM-based server processors
    prompted Facebook engineers to make its HipHop Virtual Machine JIT compilation
    engine (which runs all of Facebook&#8217;s server farms) [&#8230;]"
- id: 49973
  author: Limbajul de programare Hack, apocalipsa PHP? | Claudiu Persoiu
  author_email: ''
  author_url: http://blog.claudiupersoiu.ro/2014/04/29/limbajul-programare-apocalipsa/lang/ro/
  date: '2014-04-29 12:15:36 +0000'
  date_gmt: '2014-04-29 19:15:36 +0000'
  content: "[&#8230;] ruleaza pe HHVM. HHVM este incercarea Facebook de optimizare
    a limbajului PHP prin Just In Time complication, ultima abordare de optimizare
    a limbajului. Practic, Facebook incearca sa-si reduca din costuri, [&#8230;]"
- id: 480731
  author: Ein halbes Jahr HHVM - entwickler.de
  author_email: ''
  author_url: https://entwickler.de/online/php/ein-halbes-jahr-hhvm-138439.html
  date: '2015-05-08 02:25:56 +0000'
  date_gmt: '2015-05-08 09:25:56 +0000'
  content: "[&#8230;] set very aggressive efficiency goals for the half that we hope
    to achieve through a range of&nbsp;JIT compiler&nbsp;projects. We hope these translate
    into wins for a variety of PHP workloads. We&rsquo;re shooting for [&#8230;]"
- id: 1125509
  author: HHVM is not for WordPress &#8211; RokkiCH
  author_email: ''
  author_url: https://blog.rokki.ch/2016/09/08/hhvm-is-not-for-wordpress/
  date: '2016-09-26 14:11:44 +0000'
  date_gmt: '2016-09-26 21:11:44 +0000'
  content: "[&#8230;] beautiful and I like it for the administration simplicity and&nbsp;throughput
    benefits it offers. The JIT is performing better and better by each new release.
    This is absolutely brilliant if you&#8217;re [&#8230;]"
---

When the hhvm project was started almost 4 years ago, it had a two-part mandate: First, create a PHP [JIT](http://en.wikipedia.org/wiki/Just-in-time_compilation) that could serve [facebook.com](https://www.facebook.com/) at least as efficiently as [hphpc](http://en.wikipedia.org/wiki/HipHop_for_PHP#History_Before_HHVM), the PHP execution engine we were using at the time. Second, replace hphpi, the interpreter our PHP developers were using in their daily work. hphpc and hphpi were independent pieces of software with unintentional subtle differences in behavior and a significant maintenance burden. Unifying the execution engines used in production and development would make our jobs easier while giving the PHP devs a nicer experience at the same time. We had to find a balance between reaching these goals as quickly as possible and designing a system that could be extended and improved for many years after it replaced hphpc and hphpi. There were also concerns that just in time compilation might not be fast enough to keep up with Facebook's aggressive deployment process. We were pushing a new version of the site to our fleet of web servers once every weekday, and the whole process took less than 20 minutes. We had to maintain that ability for hhvm to be a viable option. Taking all this into account, the initial JIT design was the simplest and fastest one that we thought had a good chance of succeeding.

<!--truncate-->

If you're not familiar with the general architecture of hhvm, you might want to read through [this post](https://www.facebook.com/notes/facebook-engineering/the-hiphop-virtual-machine/10150415177928920) before continuing. Most of the JIT's functionality ended up in a C++ class named TranslatorX64. We often use "translation" to refer to the process of converting a sequence of bytecode instructions (a tracelet) into an equivalent sequence of x86-64 instructions (a translation). Once we've selected a tracelet to translate, TranslatorX64 walks through it and emits machine code for each bytecode as a self-contained unit. We knew that by doing this we would miss out on many cross-bytecode optimization opportunities, but this approach would be much simpler to implement. More importantly, we had some microbenchmark results suggesting that this would be good enough to beat hphpc. In the end, this approach was **almost** enough to get the job done.

As the summer of 2012 was drawing to a close, hhvm still wasn't competitive with hphpc and we didn't have a solid plan to change that. The project was over 2 years old by then, and we knew that if we didn't beat hphpc soon we'd have to seriously reconsider hhvm's future. The fact that hphpc had gotten about twice as fast since hhvm's birth didn't help either (though it was great news for our web servers). We went into lockdown to throw everything we had at hhvm and push it across the finish line. After a few months of working hard we comfortably beat our goal, pushing hhvm to be 10% faster than hphpc. There wasn't one big optimization that got us there; we just kept chipping away at it by making lots of small improvements like reducing cache misses, reducing code size, taking advantage of statically inferred type information, and many other tweaks. The success of hhvm was inevitable at that point, but to make it as far as we had, we needed to hack up a few of those cross-bytecode optimizations we thought we could avoid for the first iteration of the JIT. Since TranslatorX64 wasn't designed to support these optimizations, the code became increasingly more complicated and hard to work with. It was clear that while TranslatorX64 got us past the first finish line, it probably wasn't going to be enough for the future improvements we had in mind. Here's a chart of our progress (as a percentage of hphpc's efficiency) from mid 2012 to February 2013, when hphpc was completely retired:

![hhvm-vs-hphpc](/static/images/posts/hhvm-vs-hphpc1.png)

Since we're software engineers, we solved this problem by adding a new layer of indirection. This new layer is an [SSA form](http://en.wikipedia.org/wiki/Static_single_assignment_form) intermediate representation, positioned between the bytecodes in TranslatorX64's tracelets and the x86 machine code we want to end up with. It's strongly typed and designed to facilitate a number of optimizations we wanted to port from TranslatorX64 as well as new optimizations in the future. This new IR, named **hhir** (short for HipHop Intermediate Representation), completely replaced TranslatorX64 as hhvm's JIT in May of 2013. While hhir specifically refers to the representation itself, we often use the name to refer to all the pieces of code that interact with it. If you've looked at our source code recently you might have noticed that a class named TranslatorX64 still exists and contains a nontrivial amount of code. That's mostly an artifact of how the system is designed and is something we plan to eventually clean up. All of the code left in TranslatorX64 is machinery required to emit code and link translations together; the code that understood how to translate individual bytecodes is gone from TranslatorX64.

When hhir replaced TranslatorX64, it was generating code that was roughly 5% faster and looked significantly better upon manual inspection. We followed up its production debut with another mini-lockdown and got an additional 10% in performance gains on top of that. To see some of these improvements in action, let's look at a function addPositive and part of its translation.


    function addPositive($arr) {
      $n = count($arr);
      $sum = 0;
      for ($i = 0; $i < $n; $i++) {
        $elem = $arr[$i];
        if ($elem > 0) {
          $sum = $sum + $elem;
        }
      }
      return $sum;
    }


This function looks like a lot of PHP code: it loops over an array and does something with each element. Let's focus on lines 5 and 6 for now, along with their bytecode:


        $elem = $arr[$i];
        if ($elem > 0) {




      // line 5
       85: CGetM <L:0 EL:3>
       98: SetL 4
      100: PopC
      // line 6
      101: Int 0
      110: CGetL2 4
      112: Gt
      113: JmpZ 13 (126)


These two lines load an element from an array, store it in a local variable, then compare the value of that local with 0 and conditionally jump somewhere based on the result. If you're interested in more detail about what's going on in the bytecode, you can skim through [bytecode.specification](https://github.com/facebook/hhvm/blob/master/hphp/doc/bytecode.specification). The JIT, both now and back in the TranslatorX64 days, breaks this code up into two tracelets: one with just the CGetM, then another with the rest of the instructions (a full explanation of why this happens isn't relevant here, but it's mostly because we don't know at compile time what the type of the array element will be). The translation of the CGetM boils down to a call to a C++ helper function and isn't very interesting, so we'll be looking at the second tracelet. [This commit](https://github.com/facebook/hhvm/commit/f323a90b12bdd67ed695440bb82ade004b594983) was TranslatorX64's official retirement, so let's use [its parent](https://github.com/facebook/hhvm/commit/e1fb60cfcf924f60b934990b6eb5960bb8e29976) to see how TranslatorX64 translated this code.


      cmpl  $0xa, 0xc(%rbx)
      jnz 0x276004b2
      cmpl  $0xc, -0x44(%rbp)
      jnle 0x276004b2
    101: SetL 4
    103: PopC
      movq  (%rbx), %rax
      movq  -0x50(%rbp), %r13
    104: Int 0
      xor %ecx, %ecx
    113: CGetL2 4
      mov %rax, %rdx
      movl  $0xa, -0x44(%rbp)
      movq  %rax, -0x50(%rbp)
      add $0x10, %rbx
      cmp %rcx, %rdx
    115: Gt
    116: JmpZ 13 (129)
      jle 0x7608200


The first four lines are typechecks verifying that the value in $elem and the value on the top of the stack are the types we expect. If either of them fails, we'll jump to code that triggers a retranslation of the tracelet, using the new types to generate a differently specialized chunk of machine code. The meat of the translation follows, and the code has plenty of room for improvement. There's a dead load on line 8, an easily avoidable register to register move on line 12, and an opportunity for constant propagation between lines 10 and 16. These are all consequences of the bytecode-at-a-time approach used by TranslatorX64. No respectable compiler would ever emit code like this, but the simple optimizations required to avoid it just don't fit into the TranslatorX64 model.

Now let's see the same tracelet translated using hhir, at the same hhvm revision:


      cmpl  $0xa, 0xc(%rbx)
      jnz 0x276004bf
      cmpl  $0xc, -0x44(%rbp)
      jnle 0x276004bf
    101: SetL 4
      movq  (%rbx), %rcx
      movl  $0xa, -0x44(%rbp)
      movq  %rcx, -0x50(%rbp)
    115: Gt
    116: JmpZ 13 (129)
      add $0x10, %rbx
      cmp $0x0, %rcx
      jle 0x76081c0


It begins with the same typechecks but the body of the translation is 6 instructions, significantly better than the 9 from TranslatorX64. Notice that there are no dead loads or register to register moves, and the immediate 0 from the Int 0 bytecode was propagated down to the cmp on line 12. Here's the hhir that was generated between the tracelet and that translation:


      (00) DefLabel
      (02) t1:FramePtr = DefFP
      (03) t2:StkPtr = DefSP<6> t1:FramePtr
      (05) t3:StkPtr = GuardStk<Int,0> t2:StkPtr
      (06) GuardLoc<Uncounted,4> t1:FramePtr
      (11) t4:Int = LdStack<Int,0> t3:StkPtr
      (13) StLoc<4> t1:FramePtr, t4:Int
      (27) t10:StkPtr = SpillStack t3:StkPtr, 1
      (35) SyncABIRegs t1:FramePtr, t10:StkPtr
      (36) ReqBindJmpLte<129,121> t4:Int, 0


The bytecode instructions have been broken down into smaller, simpler operations. Many operations hidden in the behavior of certain bytecodes are explicitly represented in hhir, such as the LdStack on line 6 which is part of the SetL. By using unnamed temporaries (t1, t2, etc...) instead of physical registers to represent the flow of values, we can easily track the definition and use(s) of each value. This makes it trivial to see if the destination of a load is actually used, or if one of the inputs to an instruction is really a constant value from 3 bytecodes ago. For a much more thorough explanation of what hhir is and how it works, take a look at [ir.specification](https://github.com/facebook/hhvm/blob/master/hphp/doc/ir.specification).

This example showed just a few of the improvements hhir made over TranslatorX64. Getting hhir deployed to production and retiring TranslatorX64 in May 2013 was a great milestone to hit, but it was just the beginning. Since then, we've implemented many more optimizations that would be nearly impossible in TranslatorX64, making hhvm almost twice as efficient in the process. It's also been crucial in our efforts to get hhvm running on [ARM](http://en.wikipedia.org/wiki/ARM_architecture) processors by isolating and reducing the amount of architecture-specific code we need to reimplement. Watch for an upcoming post devoted to our ARM port for more details!
